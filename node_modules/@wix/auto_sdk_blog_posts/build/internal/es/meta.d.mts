import { QueryPostCountStatsRequest as QueryPostCountStatsRequest$1, QueryPostCountStatsResponse as QueryPostCountStatsResponse$1, GetTotalPostsRequest as GetTotalPostsRequest$1, GetTotalPostsResponse as GetTotalPostsResponse$1, GetPostRequest as GetPostRequest$1, GetPostResponse as GetPostResponse$1, GetPostBySlugRequest as GetPostBySlugRequest$1, GetPostBySlugResponse as GetPostBySlugResponse$1, ListPostsRequest as ListPostsRequest$1, ListPostsResponse as ListPostsResponse$1, QueryPostsRequest as QueryPostsRequest$1, QueryPostsResponse as QueryPostsResponse$1, GetPostMetricsRequest as GetPostMetricsRequest$1, GetPostMetricsResponse as GetPostMetricsResponse$1 } from './index.typings.mjs';
import '@wix/sdk-types';

interface Post {
    /**
     * Post ID.
     * @readonly
     * @format GUID
     */
    id?: string;
    /**
     * Post title.
     * @maxLength 100
     */
    title?: string;
    /**
     * Post excerpt.
     * Can be selected by a site contributor. By default, it is extracted from the content text's first characters.
     *
     * Max: 500 characters
     * @maxLength 500
     */
    excerpt?: string;
    /**
     * The post's content in plain text.
     * @readonly
     * @maxLength 400000
     */
    contentText?: string | null;
    /** Date the post was first published. */
    firstPublishedDate?: Date | null;
    /**
     * Date the post was last published.
     * @readonly
     */
    lastPublishedDate?: Date | null;
    /** Post URL. */
    url?: PageUrl;
    /**
     * Post slug. For example, `'post-slug'`.
     * @maxLength 100
     */
    slug?: string;
    /** Whether the post is marked as featured. */
    featured?: boolean;
    /** Whether the post is pinned. If `true`, the post is placed at the top of the post list. */
    pinned?: boolean;
    /**
     * [Category IDs](https://dev.wix.com/docs/rest/business-solutions/blog/category/introduction) of the post.
     * @maxSize 10
     * @format GUID
     */
    categoryIds?: string[];
    /**
     * __Deprecated.__ Use `media` instead.
     * This property will be removed on June 30, 2023.
     *
     * Post cover media.
     * @deprecated
     * @replacedBy media
     * @targetRemovalDate 2024-06-30
     */
    coverMedia?: CoverMedia;
    /**
     * Post owner's [member ID](https://dev.wix.com/api/rest/members).
     * @format GUID
     */
    memberId?: string;
    /**
     * Hashtags in the post.
     * @readonly
     * @maxSize 100
     * @maxLength 100
     */
    hashtags?: string[];
    /** Whether commenting on the post is enabled. */
    commentingEnabled?: boolean;
    /** Estimated reading time (calculated automatically). */
    minutesToRead?: number;
    /** Image placed at the top of the blog page. */
    heroImage?: Image;
    /**
     * IDs of [tags](https://dev.wix.com/docs/rest/business-solutions/blog/tags) the post is tagged with.
     * @readonly
     * @maxSize 30
     * @format GUID
     */
    tagIds?: string[];
    /**
     * IDs of posts related to the post.
     * @readonly
     * @maxSize 3
     * @format GUID
     */
    relatedPostIds?: string[];
    /**
     * [Pricing plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans). Only relevant if a post is assigned to a specific pricing plan.
     * @readonly
     * @maxSize 100
     * @format GUID
     */
    pricingPlanIds?: string[];
    /**
     * ID of the translations of this post. All translations of a single post share the same `translationId`.
     * @format GUID
     */
    translationId?: string | null;
    /**
     * Language the post is written in.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
    /** SEO data. */
    seoData?: SeoSchema;
    /**
     * Reserved for internal use.
     * @readonly
     * @maxLength 400000
     */
    content?: string | null;
    /**
     * Post owner's [contact ID](https://dev.wix.com/api/rest/contacts).
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Post rich content
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="image.gallery.video.audio.divider.linkButton.html.giphy.codeBlock.file.hashtag.lineSpacing.indent.link.textColor.textHighlight.heading.verticalEmbed.table.collapsibleList.poll" exampleid="72c23a25-524f-4f70-a260-4a2777b6f5d5">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     * @readonly
     */
    richContent?: RichContent;
    /**
     * Whether the returned content is a preview of premium content. Defaults to `false`.
     * A preview displays a limited number of paragraphs of paid content to non-subscribed users.
     * @readonly
     */
    preview?: boolean;
    /**
     * Reserved for internal use.
     * @maxLength 24
     */
    contentId?: string | null;
    /**
     * Reserved for internal use.
     * @readonly
     * @format GUID
     */
    mostRecentContributorId?: string | null;
    /**
     * Post moderation details. Only relevant to posts submitted by [guest writers](https://support.wix.com/en/article/wix-blog-moderating-blog-posts-from-your-guest-writers).
     * @readonly
     */
    moderationDetails?: ModerationDetails;
    /** Post cover media. */
    media?: Media;
    /**
     * Indicates if there is a draft post with changes that have not yet been published.
     * @readonly
     */
    hasUnpublishedChanges?: boolean;
    /**
     * Post reference ID. You can reference the post from other entities, for example, comments.
     * @readonly
     * @maxLength 24
     */
    referenceId?: string | null;
}
interface PageUrl {
    /** The base URL. For premium sites, this is the domain. For free sites, this is the site URL. For example, `mysite.wixsite.com/mysite`. */
    base?: string;
    /** The relative path for the page within the site. For example, `/product-page/a-product`. */
    path?: string;
}
interface CoverMedia extends CoverMediaMediaOneOf {
    /** Image url. */
    image?: Image;
    /** Video url. */
    video?: Video;
    /**
     * Is cover media enabled.
     * Selected by user whether to display cover media on the feed
     * @deprecated Is cover media enabled.
     * Selected by user whether to display cover media on the feed
     * @replacedBy displayed
     * @targetRemovalDate 2024-06-30
     */
    enabled?: boolean;
    /** Whether cover media is displayed. */
    displayed?: boolean;
    /** Whether cover media is custom. If `false` the cover image is set to the first media item that appears in the content. */
    custom?: boolean;
    /**
     * Media alternative text.
     * @minLength 1
     * @maxLength 1000
     */
    altText?: string | null;
}
/** @oneof */
interface CoverMediaMediaOneOf {
    /** Image url. */
    image?: Image;
    /** Video url. */
    video?: Video;
}
interface Image {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
/** Deprecated - use VideoV2 */
interface Video {
    /** WixMedia ID */
    id?: string;
    /** URL of video */
    url?: string;
    /**
     * Original image height
     * @readonly
     */
    height?: number;
    /**
     * Original image width
     * @readonly
     */
    width?: number;
    /** Video poster */
    thumbnail?: Image;
}
interface Metrics {
    /**
     * Total number of post comments.
     * @readonly
     */
    comments?: number;
    /**
     * Total number of post likes.
     * @readonly
     */
    likes?: number;
    /**
     * Total number of post views.
     * @readonly
     */
    views?: number;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /**
     * The source that added the keyword terms to the SEO settings.
     * @maxLength 1000
     */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /**
     * User-selected keyword terms for a specific page.
     * @maxSize 5
     */
    keywords?: Keyword[];
}
interface RichContent {
    /** Node objects representing a rich content document. */
    nodes?: Node[];
    /** Object metadata. */
    metadata?: Metadata;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle;
}
interface Node extends NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** @deprecated */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** LayoutData layout_data = 31; // Data for a layout node. Reserved for future use. */
    layoutCellData?: LayoutCellData;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeTypeWithLiterals;
    /** Node ID. */
    id?: string;
    /** A list of child nodes. */
    nodes?: Node[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle;
}
/** @oneof */
interface NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** @deprecated */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** LayoutData layout_data = 31; // Data for a layout node. Reserved for future use. */
    layoutCellData?: LayoutCellData;
}
declare enum NodeType {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    /** @deprecated */
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION",
    LAYOUT = "LAYOUT",
    LAYOUT_CELL = "LAYOUT_CELL"
}
/** @enumType */
type NodeTypeWithLiterals = NodeType | 'PARAGRAPH' | 'TEXT' | 'HEADING' | 'BULLETED_LIST' | 'ORDERED_LIST' | 'LIST_ITEM' | 'BLOCKQUOTE' | 'CODE_BLOCK' | 'VIDEO' | 'DIVIDER' | 'FILE' | 'GALLERY' | 'GIF' | 'HTML' | 'IMAGE' | 'LINK_PREVIEW' | 'MAP' | 'POLL' | 'APP_EMBED' | 'BUTTON' | 'COLLAPSIBLE_LIST' | 'TABLE' | 'EMBED' | 'COLLAPSIBLE_ITEM' | 'COLLAPSIBLE_ITEM_TITLE' | 'COLLAPSIBLE_ITEM_BODY' | 'TABLE_CELL' | 'TABLE_ROW' | 'EXTERNAL' | 'AUDIO' | 'CAPTION' | 'LAYOUT' | 'LAYOUT_CELL';
interface NodeStyle {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData {
    /** Styling for the button's container. */
    containerData?: PluginContainerData;
    /** The button type. */
    type?: ButtonDataTypeWithLiterals;
    /** Styling for the button. */
    styles?: Styles;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link;
}
interface Border {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignmentWithLiterals;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler;
    /** The height of the node when it's displayed. */
    height?: Height;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
/** @enumType */
type WidthTypeWithLiterals = WidthType | 'CONTENT' | 'SMALL' | 'ORIGINAL' | 'FULL_WIDTH';
interface PluginContainerDataWidth extends PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthTypeWithLiterals;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthTypeWithLiterals;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
/** @enumType */
type PluginContainerDataAlignmentWithLiterals = PluginContainerDataAlignment | 'CENTER' | 'LEFT' | 'RIGHT';
interface Spoiler {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum ButtonDataType {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
/** @enumType */
type ButtonDataTypeWithLiterals = ButtonDataType | 'LINK' | 'ACTION';
interface Styles {
    /** Border attributes. */
    border?: Border;
    /** Color attributes. */
    colors?: Colors;
}
interface Link extends LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: TargetWithLiterals;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
/** @enumType */
type TargetWithLiterals = Target | 'SELF' | 'BLANK' | 'PARENT' | 'TOP';
interface Rel {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the pageâ€™s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData {
    /** Styling for the code block's text. */
    textStyle?: TextStyle;
}
interface TextStyle {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignmentWithLiterals;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
/** @enumType */
type TextAlignmentWithLiterals = TextAlignment | 'AUTO' | 'LEFT' | 'RIGHT' | 'CENTER' | 'JUSTIFY';
interface DividerData {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData;
    /** Divider line style. */
    lineStyle?: LineStyleWithLiterals;
    /** Divider width. */
    width?: WidthWithLiterals;
    /** Divider alignment. */
    alignment?: DividerDataAlignmentWithLiterals;
}
declare enum LineStyle {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
/** @enumType */
type LineStyleWithLiterals = LineStyle | 'SINGLE' | 'DOUBLE' | 'DASHED' | 'DOTTED';
declare enum Width {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
/** @enumType */
type WidthWithLiterals = Width | 'LARGE' | 'MEDIUM' | 'SMALL';
declare enum DividerDataAlignment {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
/** @enumType */
type DividerDataAlignmentWithLiterals = DividerDataAlignment | 'CENTER' | 'LEFT' | 'RIGHT';
interface FileData {
    /** Styling for the file's container. */
    containerData?: PluginContainerData;
    /** The source for the file's data. */
    src?: FileSource;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
/** @enumType */
type ViewModeWithLiterals = ViewMode | 'NONE' | 'FULL' | 'MINI';
interface FileSource extends FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
}
interface PDFSettings {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewModeWithLiterals;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData;
    /** The items in the gallery. */
    items?: Item[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface V1Media {
    /** The source for the media's data. */
    src?: FileSource;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface ItemImage {
    /** Image file details. */
    media?: V1Media;
    /** Link details for images that are links. */
    link?: Link;
}
interface ItemVideo {
    /** Video file details. */
    media?: V1Media;
    /** Video thumbnail file details. */
    thumbnail?: V1Media;
}
interface Item extends ItemDataOneOf {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: ItemVideo;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: ItemVideo;
}
interface GalleryOptions {
    /** Gallery layout. */
    layout?: GalleryOptionsLayout;
    /** Styling for gallery items. */
    item?: ItemStyle;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails;
}
declare enum LayoutType {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
/** @enumType */
type LayoutTypeWithLiterals = LayoutType | 'COLLAGE' | 'MASONRY' | 'GRID' | 'THUMBNAIL' | 'SLIDER' | 'SLIDESHOW' | 'PANORAMA' | 'COLUMN' | 'MAGIC' | 'FULLSIZE';
declare enum Orientation {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
/** @enumType */
type OrientationWithLiterals = Orientation | 'ROWS' | 'COLUMNS';
declare enum Crop {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
/** @enumType */
type CropWithLiterals = Crop | 'FILL' | 'FIT';
declare enum ThumbnailsAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
/** @enumType */
type ThumbnailsAlignmentWithLiterals = ThumbnailsAlignment | 'TOP' | 'RIGHT' | 'BOTTOM' | 'LEFT' | 'NONE';
interface GalleryOptionsLayout {
    /** Gallery layout type. */
    type?: LayoutTypeWithLiterals;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: OrientationWithLiterals;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: CropWithLiterals;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignmentWithLiterals;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData;
    /** The source of the full size GIF. */
    original?: GIF;
    /** The source of the downsized GIF. */
    downsized?: GIF;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
    /** Type of GIF (Sticker or GIF). Defaults to `GIF`. */
    gifType?: GIFTypeWithLiterals;
}
interface GIF {
    /**
     * GIF format URL.
     * @format WEB_URL
     */
    gif?: string | null;
    /**
     * MP4 format URL.
     * @format WEB_URL
     */
    mp4?: string | null;
    /**
     * Thumbnail URL.
     * @format WEB_URL
     */
    still?: string | null;
}
declare enum GIFType {
    GIF = "GIF",
    STICKER = "STICKER"
}
/** @enumType */
type GIFTypeWithLiterals = GIFType | 'GIF' | 'STICKER';
interface HeadingData {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData extends HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. Height property is irrelevant for HTML embeds when autoHeight is set to `true`. */
    containerData?: PluginContainerData;
    /** The type of HTML code. */
    source?: SourceWithLiterals;
    /** If container height is aligned with its content height. Defaults to `true`. */
    autoHeight?: boolean | null;
}
/** @oneof */
interface HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
/** @enumType */
type SourceWithLiterals = Source | 'HTML' | 'ADSENSE';
interface ImageData {
    /** Styling for the image's container. */
    containerData?: PluginContainerData;
    /** Image file details. */
    image?: V1Media;
    /** Link details for images that are links. */
    link?: Link;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData;
    /** Link details. */
    link?: Link;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData {
    /** Styling for the map's container. */
    containerData?: PluginContainerData;
    /** Map settings. */
    mapSettings?: MapSettings;
}
interface MapSettings {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapTypeWithLiterals;
}
declare enum MapType {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
/** @enumType */
type MapTypeWithLiterals = MapType | 'ROADMAP' | 'SATELITE' | 'HYBRID' | 'TERRAIN';
interface ParagraphData {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData;
    /** Poll data. */
    poll?: Poll;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout;
    /** Styling for the poll and voting options. */
    design?: Design;
}
declare enum ViewRole {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
/** @enumType */
type ViewRoleWithLiterals = ViewRole | 'CREATOR' | 'VOTERS' | 'EVERYONE';
declare enum VoteRole {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
/** @enumType */
type VoteRoleWithLiterals = VoteRole | 'SITE_MEMBERS' | 'ALL';
interface Permissions {
    /** Sets who can view the poll results. */
    view?: ViewRoleWithLiterals;
    /** Sets who can vote. */
    vote?: VoteRoleWithLiterals;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option {
    /** Option ID. */
    id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: V1Media;
}
interface PollSettings {
    /** Permissions settings for voting. */
    permissions?: Permissions;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
/** @enumType */
type PollLayoutTypeWithLiterals = PollLayoutType | 'LIST' | 'GRID';
declare enum PollLayoutDirection {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
/** @enumType */
type PollLayoutDirectionWithLiterals = PollLayoutDirection | 'LTR' | 'RTL';
interface PollLayout {
    /** The layout for displaying the voting options. */
    type?: PollLayoutTypeWithLiterals;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirectionWithLiterals;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
/** @enumType */
type BackgroundTypeWithLiterals = BackgroundType | 'COLOR' | 'IMAGE' | 'GRADIENT';
interface Gradient {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /**
     * The start color as a hexademical value.
     * @format COLOR_HEX
     */
    startColor?: string | null;
    /**
     * The end color as a hexademical value.
     * @format COLOR_HEX
     */
    lastColor?: string | null;
}
interface Background extends BackgroundBackgroundOneOf {
    /**
     * The background color as a hexademical value.
     * @format COLOR_HEX
     */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundTypeWithLiterals;
}
/** @oneof */
interface BackgroundBackgroundOneOf {
    /**
     * The background color as a hexademical value.
     * @format COLOR_HEX
     */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
}
interface PollDesign {
    /** Background styling. */
    background?: Background;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll {
    /** Poll ID. */
    id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: V1Media;
    /** Voting options. */
    options?: Option[];
    /** The poll's permissions and display settings. */
    settings?: PollSettings;
}
interface PollDataLayout {
    /** Poll layout settings. */
    poll?: PollLayout;
    /** Voting otpions layout settings. */
    options?: OptionLayout;
}
interface Design {
    /** Styling for the poll. */
    poll?: PollDesign;
    /** Styling for voting options. */
    options?: OptionDesign;
}
interface TextData {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration[];
}
/** Adds appearence changes to text */
interface Decoration extends DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
    /** The type of decoration to apply. */
    type?: DecorationTypeWithLiterals;
}
/** @oneof */
interface DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
}
declare enum DecorationType {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
/** @enumType */
type DecorationTypeWithLiterals = DecorationType | 'BOLD' | 'ITALIC' | 'UNDERLINE' | 'SPOILER' | 'ANCHOR' | 'MENTION' | 'LINK' | 'COLOR' | 'FONT_SIZE' | 'EXTERNAL';
interface AnchorData {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData {
    /** Link details. */
    link?: Link;
}
interface MentionData {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    id?: string | null;
}
interface FontSizeData {
    /** The units used for the font size. */
    unit?: FontTypeWithLiterals;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType {
    PX = "PX",
    EM = "EM"
}
/** @enumType */
type FontTypeWithLiterals = FontType | 'PX' | 'EM';
interface SpoilerData {
    /** Spoiler ID. */
    id?: string | null;
}
interface AppEmbedData extends AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
    /** The type of Wix App content being embedded. */
    type?: AppTypeWithLiterals;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: V1Media;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
}
declare enum AppType {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
/** @enumType */
type AppTypeWithLiterals = AppType | 'PRODUCT' | 'EVENT' | 'BOOKING';
interface BookingData {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData {
    /** Styling for the video's container. */
    containerData?: PluginContainerData;
    /** Video details. */
    video?: V1Media;
    /** Video thumbnail details. */
    thumbnail?: V1Media;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions;
}
interface PlaybackOptions {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItemsWithLiterals;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: DirectionWithLiterals;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
/** @enumType */
type InitialExpandedItemsWithLiterals = InitialExpandedItems | 'FIRST' | 'ALL' | 'NONE';
declare enum Direction {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
/** @enumType */
type DirectionWithLiterals = Direction | 'LTR' | 'RTL';
interface TableData {
    /** Styling for the table's container. */
    containerData?: PluginContainerData;
    /** The table's dimensions. */
    dimensions?: Dimensions;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle;
    /** The cell's border colors. */
    borderColors?: BorderColors;
}
declare enum VerticalAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
/** @enumType */
type VerticalAlignmentWithLiterals = VerticalAlignment | 'TOP' | 'MIDDLE' | 'BOTTOM';
interface CellStyle {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignmentWithLiterals;
    /**
     * Cell background color as a hexadecimal value.
     * @format COLOR_HEX
     */
    backgroundColor?: string | null;
}
interface BorderColors {
    /**
     * Left border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    left?: string | null;
    /**
     * Right border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    right?: string | null;
    /**
     * Top border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    top?: string | null;
    /**
     * Bottom border color as a hexadecimal value.
     * @format COLOR_HEX
     */
    bottom?: string | null;
}
interface AudioData {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData;
    /** Audio file details. */
    audio?: V1Media;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: V1Media;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData {
    textStyle?: TextStyle;
}
interface LayoutCellData {
    /** Size of the cell in 12 columns grid. */
    colSpan?: number | null;
}
interface Metadata {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    id?: string | null;
}
interface DocumentStyle {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle;
}
interface TextNodeStyle {
    /** The decorations to apply to the node. */
    decorations?: Decoration[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface ModerationDetails {
    /**
     * Member ID of the person submitting the draft post for review.
     * @format GUID
     */
    submittedBy?: string;
    /** Date the post was submitted for review. */
    submittedDate?: Date | null;
    /** Status indicating whether the submission was approved or rejected by the moderator. */
    status?: ModerationStatusStatusWithLiterals;
    /**
     * Member ID of the person who approved or rejected the post.
     * @format GUID
     */
    moderatedBy?: string | null;
    /** Date the post was approved or rejected. */
    moderationDate?: Date | null;
}
declare enum ModerationStatusStatus {
    UNKNOWN = "UNKNOWN",
    APPROVED = "APPROVED",
    REJECTED = "REJECTED"
}
/** @enumType */
type ModerationStatusStatusWithLiterals = ModerationStatusStatus | 'UNKNOWN' | 'APPROVED' | 'REJECTED';
interface Media extends MediaMediaOneOf {
    /** Wix Media details. */
    wixMedia?: WixMedia;
    /** Embed media details. */
    embedMedia?: EmbedMedia;
    /** Whether cover media is displayed. */
    displayed?: boolean;
    /** Whether custom cover media has been specified. If `false`, the first media item in the post's content serves as cover media. */
    custom?: boolean;
    /**
     * Media alternative text.
     * @minLength 1
     * @maxLength 1000
     */
    altText?: string | null;
}
/** @oneof */
interface MediaMediaOneOf {
    /** Wix Media details. */
    wixMedia?: WixMedia;
    /** Embed media details. */
    embedMedia?: EmbedMedia;
}
interface WixMedia {
    /** Image details. */
    image?: Image;
    /** Video details. */
    videoV2?: VideoV2;
}
interface VideoV2 {
    /** WixMedia ID. */
    id?: string;
    /**
     * Available resolutions for the video, starting with the optimal resolution.
     * @readonly
     * @maxSize 100
     */
    resolutions?: VideoResolution[];
    /**
     * Video filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoResolution {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /** Video format for example, mp4, hls. */
    format?: string;
}
interface EmbedMedia {
    /** Thumbnail details. */
    thumbnail?: EmbedThumbnail;
    /** Video details. */
    video?: EmbedVideo;
}
interface EmbedThumbnail {
    /**
     * Thumbnail url.
     * @maxLength 2000
     */
    url?: string;
    /** Thumbnail width. */
    width?: number;
    /** Thumbnail height. */
    height?: number;
}
interface EmbedVideo {
    /**
     * Video url.
     * @maxLength 2000
     */
    url?: string;
    /** Video width. */
    width?: number;
    /** Video height. */
    height?: number;
}
/** Get Blog Post Count Stats request */
interface QueryPostCountStatsRequest {
    /** Start of time range to return, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time format. */
    rangeStart?: Date | null;
    /**
     * Order of returned results.
     *
     * - `OLDEST`: posts by date in ascending order.
     * - `NEWEST`: posts by date in descending order.
     *
     * Default: `OLDEST`
     */
    order?: OrderWithLiterals;
    /** Number of months to include in response. */
    months?: number;
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive the period post count for that specified language.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
    /**
     * Time zone to use when calculating the start of the month.
     *
     * [UTC timezone offset](https://en.wikipedia.org/wiki/List_of_UTC_offsets) format. For example, New York time zone is `-05`.
     * @minLength 3
     * @maxLength 100
     */
    timeZone?: string | null;
}
declare enum Order {
    UNKNOWN = "UNKNOWN",
    OLDEST = "OLDEST",
    NEWEST = "NEWEST"
}
/** @enumType */
type OrderWithLiterals = Order | 'UNKNOWN' | 'OLDEST' | 'NEWEST';
/** Get Blog Post Count Stats response */
interface QueryPostCountStatsResponse {
    /** List of published post counts by month. */
    stats?: PeriodPostCount[];
}
/** Post count for a specific time period */
interface PeriodPostCount {
    /** Start of time range in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time format. */
    periodStart?: Date | null;
    /** Number of posts published during this month. */
    postCount?: number;
}
interface GetTotalPostsRequest {
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to receive the total amount of posts in that specified language.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
interface GetTotalPostsResponse {
    /** Total amount of published posts. */
    total?: number;
}
interface BlogPaging {
    /**
     * Number of items to skip in the current sort order.
     *
     *
     * Default: `0`
     */
    offset?: number;
    /**
     * Number of items to return.
     *
     *
     * Default:`50`
     * @min 1
     * @max 100
     */
    limit?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface MetaData {
    /** Number of items returned in this response. */
    count?: number;
    /** Requested offset. */
    offset?: number;
    /** Total number of items that match the query. */
    total?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface GetPostRequest {
    /**
     * Post ID.
     * @minLength 1
     * @maxLength 38
     */
    postId: string;
    /**
     * List of additional post fields to include in the response. For example, use the `URL` fieldset to retrieve the url field in
     * the response in addition to the postâ€™s base fields. Base fields donâ€™t include any of the supported fieldset values. By default
     * only the postâ€™s base fields are returned.
     * @maxSize 20
     */
    fieldsets?: PostFieldFieldWithLiterals[];
}
declare enum PostFieldField {
    UNKNOWN = "UNKNOWN",
    /** Includes post URL when present. */
    URL = "URL",
    /** Includes post content text string when present. */
    CONTENT_TEXT = "CONTENT_TEXT",
    /** Includes post metrics when present. */
    METRICS = "METRICS",
    /** Includes SEO data. */
    SEO = "SEO",
    /** Includes post owner's contact ID. */
    CONTACT_ID = "CONTACT_ID",
    /** Includes post rich content. */
    RICH_CONTENT = "RICH_CONTENT",
    /** Includes post reference ID field. */
    REFERENCE_ID = "REFERENCE_ID"
}
/** @enumType */
type PostFieldFieldWithLiterals = PostFieldField | 'UNKNOWN' | 'URL' | 'CONTENT_TEXT' | 'METRICS' | 'SEO' | 'CONTACT_ID' | 'RICH_CONTENT' | 'REFERENCE_ID';
interface GetPostResponse {
    /** Retrieved post info. */
    post?: Post;
}
interface GetPostBySlugRequest {
    /**
     * Slug of the post to retrieve.
     * @minLength 1
     * @maxLength 200
     */
    slug: string;
    /**
     * List of additional post fields to include in the response. For example, use the `URL` fieldset to retrieve the url field in
     * the response in addition to the postâ€™s base fields. Base fields donâ€™t include any of the supported fieldset values. By default
     * only the postâ€™s base fields are returned.
     * @maxSize 20
     */
    fieldsets?: PostFieldFieldWithLiterals[];
}
interface GetPostBySlugResponse {
    /** Retrieved post info. */
    post?: Post;
}
interface ListPostsRequest {
    /**
     * Whether to return only featured posts.
     *
     * Default: `false`
     */
    featured?: boolean;
    /**
     * Hashtag filter.
     *
     * Pass an array of hashtags to return only posts containing any of the provided hashtags.
     * If omitted, all posts with or without hashtags are returned.
     * @maxSize 100
     * @maxLength 100
     */
    hashtags?: string[];
    /**
     * Category filter.
     *
     * Pass an array of category IDs to return only posts with any of the provided categories.
     * If omitted, all posts with or without associated categories are returned.
     * @maxSize 50
     * @maxLength 38
     */
    categoryIds?: string[];
    /**
     * Tag filter.
     *
     * Pass an array of tag IDs to return only posts with any of the provided tags.
     * If omitted, all posts with or without tags are returned.
     * @maxSize 50
     * @maxLength 38
     */
    tagIds?: string[];
    /**
     * Sorting options.
     *
     * Default: `FEED`
     */
    sort?: GetPostsSortWithLiterals;
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive posts that are in that language.
     * If omitted, posts in all languages are returned.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
    /**
     * Post owner's member ID.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * List of additional post fields to include in the response. For example, use the `URL` fieldset to retrieve the url field in
     * the response in addition to the postâ€™s base fields. Base fields donâ€™t include any of the supported fieldset values. By default
     * only the postâ€™s base fields are returned.
     * @maxSize 20
     */
    fieldsets?: PostFieldFieldWithLiterals[];
}
declare enum GetPostsSort {
    /** Ordered by `firstPublishedDate` in descending order with pinned posts first. */
    FEED = "FEED",
    /** Ordered by `firstPublishedDate` in ascending order. */
    PUBLISHED_DATE_ASC = "PUBLISHED_DATE_ASC",
    /** Ordered by `firstPublishedDate` in descending order. */
    PUBLISHED_DATE_DESC = "PUBLISHED_DATE_DESC",
    /** Ordered by total number of views in descending order. */
    VIEW_COUNT = "VIEW_COUNT",
    /** Ordered by total number of likes in descending order. */
    LIKE_COUNT = "LIKE_COUNT",
    /** Ordered by `title` in ascening order. */
    TITLE_ASC = "TITLE_ASC",
    /** Ordered by `title` in descending order. */
    TITLE_DESC = "TITLE_DESC"
}
/** @enumType */
type GetPostsSortWithLiterals = GetPostsSort | 'FEED' | 'PUBLISHED_DATE_ASC' | 'PUBLISHED_DATE_DESC' | 'VIEW_COUNT' | 'LIKE_COUNT' | 'TITLE_ASC' | 'TITLE_DESC';
interface ListPostsResponse {
    /** List of retrieved posts. */
    posts?: Post[];
    /** Details on the paged set of results returned. */
    metaData?: MetaData;
}
interface QueryPostsRequest {
    /** Query options. */
    query?: PlatformQuery;
    /**
     * List of additional post fields to include in the response. For example, use the `URL` fieldset to retrieve the url field in
     * the response in addition to the postâ€™s base fields. Base fields donâ€™t include any of the supported fieldset values. By default
     * only the postâ€™s base fields are returned.
     * @maxSize 20
     */
    fieldsets?: PostFieldFieldWithLiterals[];
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 3
     */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Paging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface QueryPostsResponse {
    /** List of retrieved posts. */
    posts?: Post[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor pointing to next page in the list of results.
     * @maxLength 2000
     */
    next?: string | null;
    /**
     * Cursor pointing to previous page in the list of results.
     * @maxLength 2000
     */
    prev?: string | null;
}
interface GetPostMetricsRequest {
    /**
     * Post ID to retrieve metrics for.
     * @minLength 1
     * @maxLength 38
     */
    postId: string;
}
interface GetPostMetricsResponse {
    /** Retrieved post metrics. */
    metrics?: Metrics;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function queryPostCountStats(): __PublicMethodMetaInfo<'GET', {}, QueryPostCountStatsRequest$1, QueryPostCountStatsRequest, QueryPostCountStatsResponse$1, QueryPostCountStatsResponse>;
declare function getTotalPosts(): __PublicMethodMetaInfo<'GET', {}, GetTotalPostsRequest$1, GetTotalPostsRequest, GetTotalPostsResponse$1, GetTotalPostsResponse>;
declare function getPost(): __PublicMethodMetaInfo<'GET', {
    postId: string;
}, GetPostRequest$1, GetPostRequest, GetPostResponse$1, GetPostResponse>;
declare function getPostBySlug(): __PublicMethodMetaInfo<'GET', {
    slug: string;
}, GetPostBySlugRequest$1, GetPostBySlugRequest, GetPostBySlugResponse$1, GetPostBySlugResponse>;
declare function listPosts(): __PublicMethodMetaInfo<'GET', {}, ListPostsRequest$1, ListPostsRequest, ListPostsResponse$1, ListPostsResponse>;
declare function queryPosts(): __PublicMethodMetaInfo<'POST', {}, QueryPostsRequest$1, QueryPostsRequest, QueryPostsResponse$1, QueryPostsResponse>;
declare function getPostMetrics(): __PublicMethodMetaInfo<'GET', {
    postId: string;
}, GetPostMetricsRequest$1, GetPostMetricsRequest, GetPostMetricsResponse$1, GetPostMetricsResponse>;

export { type __PublicMethodMetaInfo, getPost, getPostBySlug, getPostMetrics, getTotalPosts, listPosts, queryPostCountStats, queryPosts };
