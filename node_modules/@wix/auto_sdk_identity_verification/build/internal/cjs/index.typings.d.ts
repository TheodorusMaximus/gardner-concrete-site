import { NonNullablePaths } from '@wix/sdk-types';

interface StartResponse {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     * @format GUID
     */
    identityId?: string | null;
    /** the delivery target */
    target?: TargetWithLiterals;
}
declare enum Target {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
/** @enumType */
type TargetWithLiterals = Target | 'UNKNOWN_TARGET' | 'EMAIL';
interface VerifyRequest {
    /**
     * the code to verify
     * @minLength 6
     * @maxLength 6
     */
    code?: string;
    /** the identifier of the verification process */
    verificationId?: string;
}
interface VerifyResponse {
}
interface VerifyDuringAuthenticationRequest {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateTypeWithLiterals;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
interface StateMachineResponseStateDataOneOf {
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
/** @enumType */
type StateTypeWithLiterals = StateType | 'UNKNOWN_STATE' | 'SUCCESS' | 'REQUIRE_OWNER_APPROVAL' | 'REQUIRE_EMAIL_VERIFICATION' | 'STATUS_CHECK';
interface Identity {
    /**
     * Identity ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @maxSize 10
     * @readonly
     */
    factors?: Factor[];
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /**
     * IDP connection ID.
     * @format GUID
     */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /**
     * Authenticator connection ID.
     * @format GUID
     */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /**
     * List of profile labels.
     * @maxSize 2000
     */
    labels?: string[];
    /**
     * Profile language.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatusWithLiterals;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /**
     * Company name.
     * @maxLength 1000
     */
    company?: string | null;
    /**
     * Position within company.
     * @maxLength 1000
     */
    position?: string | null;
    /**
     * Profile birthdate in `YYYY-MM-DD` format.
     * @format LOCAL_DATE
     */
    birthdate?: string | null;
    /**
     * Profile slug.
     * @maxLength 255
     */
    slug?: string | null;
    /** Consent to be added to mailing list */
    subscription?: boolean | null;
    /**
     * Government id for personal/corporate (Vat ID).
     * @maxLength 1000
     */
    vatId?: string | null;
}
declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type PrivacyStatusWithLiterals = PrivacyStatus | 'UNDEFINED' | 'PUBLIC' | 'PRIVATE';
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /**
     * Email address.
     * @format EMAIL
     */
    email?: string;
    /** Email tag. */
    tag?: EmailTagWithLiterals;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
/** @enumType */
type EmailTagWithLiterals = EmailTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'WORK';
interface Phone {
    /**
     * Phone country code.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTagWithLiterals;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
/** @enumType */
type PhoneTagWithLiterals = PhoneTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'MOBILE' | 'WORK' | 'FAX';
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTagWithLiterals;
}
/** Physical address */
interface Address {
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
/** @enumType */
type AddressTagWithLiterals = AddressTag | 'UNTAGGED' | 'HOME' | 'WORK' | 'BILLING' | 'SHIPPING';
interface Metadata {
}
interface Email {
    /**
     * Email address.
     * @format EMAIL
     */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
interface StatusV2 {
    /** Descriptive name of the identity status. */
    name?: StatusNameWithLiterals;
    /** Reasons for the current identity status. */
    reasons?: ReasonWithLiterals[];
}
declare enum StatusName {
    /** Unknown status. This value isn't used. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Identity is pending verification, owner approval, or both. */
    PENDING = "PENDING",
    /** Identity is active and can log in. */
    ACTIVE = "ACTIVE",
    /** Identity is deleted. This identity can't log in. */
    DELETED = "DELETED",
    /** Identity is blocked. This identity can't log in. */
    BLOCKED = "BLOCKED",
    /** Identity is offline. This identity can't log in. */
    OFFLINE = "OFFLINE"
}
/** @enumType */
type StatusNameWithLiterals = StatusName | 'UNKNOWN_STATUS' | 'PENDING' | 'ACTIVE' | 'DELETED' | 'BLOCKED' | 'OFFLINE';
declare enum Reason {
    /** Unknown reason. This value isn't used. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** The identity is waiting for admin approval. After the approval, the identity has an `ACTIVE` status. */
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    /** The identity has to verify the email. After the verification, the identity has an `ACTIVE` status. */
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'PENDING_ADMIN_APPROVAL_REQUIRED' | 'PENDING_EMAIL_VERIFICATION_REQUIRED';
interface Factor {
    /**
     * Factor ID.
     * @format GUID
     */
    factorId?: string;
    /** Factor type. */
    type?: FactorTypeWithLiterals;
    /** Factor status. */
    status?: StatusWithLiterals;
}
declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH",
    /** Requires authentication via WebAuthn/passkey. */
    WEBAUTHN = "WEBAUTHN"
}
/** @enumType */
type FactorTypeWithLiterals = FactorType | 'UNKNOWN_FACTOR_TYPE' | 'PASSWORD' | 'SMS' | 'CALL' | 'EMAIL' | 'TOTP' | 'PUSH' | 'WEBAUTHN';
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
/** @enumType */
type StatusWithLiterals = Status | 'INACTIVE' | 'ACTIVE' | 'REQUIRE_REENROLL';
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface RequireMfaData {
    /**
     * The factors available for the user to perform the required MFA.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface V1Factor {
    /** Type of verification factor. */
    factorType?: FactorTypeWithLiterals;
    /** Availability status for second factor */
    factorStatus?: FactorStatusWithLiterals;
}
declare enum FactorStatus {
    UNKNOWN_FACTOR_STATUS = "UNKNOWN_FACTOR_STATUS",
    ENABLED = "ENABLED",
    REQUIRE_ACTIVATION = "REQUIRE_ACTIVATION",
    REQUIRE_REENROLL = "REQUIRE_REENROLL",
    ENABLED_BY_RULE = "ENABLED_BY_RULE",
    DISABLED_BY_RULE = "DISABLED_BY_RULE"
}
/** @enumType */
type FactorStatusWithLiterals = FactorStatus | 'UNKNOWN_FACTOR_STATUS' | 'ENABLED' | 'REQUIRE_ACTIVATION' | 'REQUIRE_REENROLL' | 'ENABLED_BY_RULE' | 'DISABLED_BY_RULE';
declare enum MfaReason {
    UNKNOWN_MFA_REASON = "UNKNOWN_MFA_REASON",
    /** Mfa is required due to user settings */
    USER_SETTINGS = "USER_SETTINGS",
    /** Mfa is required due to high risk login */
    HIGH_RISK_LOGIN = "HIGH_RISK_LOGIN"
}
/** @enumType */
type MfaReasonWithLiterals = MfaReason | 'UNKNOWN_MFA_REASON' | 'USER_SETTINGS' | 'HIGH_RISK_LOGIN';
interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorTypeWithLiterals;
    verificationChallengeData?: VerificationChallenge;
    /**
     * Factors types the user can choose from to verify themselves.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required for verification. */
    reason?: MfaReasonWithLiterals;
}
interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
    /** @maxLength 200 */
    hint?: string | null;
}
/** @oneof */
interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
}
interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     * @maxLength 36
     */
    transactionId?: string;
}
interface WebAuthnChallengeData {
    /**
     * A unique identifier for this challenge that will be used to correlate
     * the authentication response with this challenge.
     * This should be a cryptographically random GUID to prevent guessing attacks.
     * @format GUID
     */
    challengeId?: string;
    /**
     * The challenge that will be signed by the authenticator during the WebAuthn authentication ceremony.
     * This should be a cryptographically secure random value with at least 16 bytes of entropy.
     * The value is used to prevent replay attacks and MUST be randomly generated by the implementer.
     */
    challenge?: Uint8Array;
    /**
     * The timeout in milliseconds for the WebAuthn authentication ceremony.
     * After this time, the challenge will be considered expired and the authentication will need to be restarted.
     * This is optional and may be overridden by the client if provided.
     * The WebAuthn spec recommends a timeout of at least 1 minute (60000ms).
     */
    timeoutMs?: number | null;
    /**
     * Optional list of credentials that are acceptable for this authentication ceremony.
     * If empty, all credentials associated with the user will be considered.
     * @maxSize 10
     */
    allowCredentials?: PublicKeyCredentialDescriptor[];
    /** Specifies the requirement for user verification during the authentication ceremony. */
    userVerification?: UserVerificationRequirementWithLiterals;
    /**
     * Optional hints to guide the client UI
     * Examples include "security-key" to emphasize external authenticators
     * or "client-device" to emphasize built-in authenticators
     * @maxLength 50
     * @maxSize 10
     */
    hints?: string[];
    /**
     * Optional extensions for the authentication ceremony
     * Provides additional parameters for specialized WebAuthn functionality
     */
    extensions?: AuthenticationExtensionInputs;
}
interface PublicKeyCredentialDescriptor {
    /** The credential ID */
    _id?: Uint8Array;
    /**
     * An optional hint as to the transports used by the credential
     * Examples include "usb", "nfc", "ble", "internal", "hybrid"
     * @maxLength 50
     * @maxSize 10
     */
    transports?: string[];
}
declare enum UserVerificationRequirement {
    /** Default unspecified value */
    USER_VERIFICATION_UNSPECIFIED = "USER_VERIFICATION_UNSPECIFIED",
    /**
     * The Relying Party requires user verification and will fail the operation if the response doesn't have the UV flag
     * set
     */
    USER_VERIFICATION_REQUIRED = "USER_VERIFICATION_REQUIRED",
    /** The Relying Party prefers user verification but will not fail the operation if unavailable */
    USER_VERIFICATION_PREFERRED = "USER_VERIFICATION_PREFERRED",
    /** The Relying Party does not want user verification employed (e.g., to minimize disruption to the user experience) */
    USER_VERIFICATION_DISCOURAGED = "USER_VERIFICATION_DISCOURAGED"
}
/** @enumType */
type UserVerificationRequirementWithLiterals = UserVerificationRequirement | 'USER_VERIFICATION_UNSPECIFIED' | 'USER_VERIFICATION_REQUIRED' | 'USER_VERIFICATION_PREFERRED' | 'USER_VERIFICATION_DISCOURAGED';
interface AuthenticationExtensionInputs extends AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
    /**
     * FIDO AppID Extension (appid)
     * An AppID that was used for previously registered U2F authenticators
     * This makes already-registered U2F credentials forward-compatible with the WebAuthn API
     * @maxLength 256
     */
    appid?: string;
    /**
     * User Verification Method Extension (uvm)
     * Requests the authenticator to report which verification methods were used
     * Examples include fingerprint, PIN, or facial recognition
     */
    uvm?: boolean;
}
/** @oneof */
interface AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
}
interface ResendDuringAuthenticationRequest {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
type StartResponseNonNullablePaths = `verificationId`;
/**
 * starts a verification process
 * example: sends a code to the identity's email
 * @public
 * @documentationMaturity preview
 * @permissionId IAM.START
 * @fqn wix.iam.verification.v1.VerificationService.Start
 */
declare function start(options?: StartOptions): Promise<NonNullablePaths<StartResponse, StartResponseNonNullablePaths>>;
interface StartOptions {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     * @format GUID
     */
    identityId?: string | null;
    /** the delivery target */
    target?: TargetWithLiterals;
}
/**
 * Continues the registration process when a member is required to verify an email address
 * using a verification code received by email.
 *
 * Email verification is required when the registering member is already listed as a contact.
 *
 * Typically, after a successful verification, you generate and use member tokens for the
 * registered member so that subsequent API calls are called as part of a member session.
 * @param code - The code to verify.
 * @public
 * @documentationMaturity preview
 * @requiredField code
 * @requiredField options
 * @requiredField options.stateToken
 * @fqn wix.iam.verification.v1.VerificationService.VerifyDuringAuthentication
 */
declare function verifyDuringAuthentication(code: string, options: NonNullablePaths<VerifyDuringAuthenticationOptions, `stateToken`>): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
interface VerifyDuringAuthenticationOptions {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
/**
 * Resend the verification email and continue the registration process when a member is required to verify an email address
 * using a verification code received by email.
 * @param stateToken - A state token representing the `REQUIRE_EMAIL_VERIFICATION` state.
 * @public
 * @documentationMaturity preview
 * @requiredField stateToken
 * @permissionId IAM.RESEND_DURING_AUTHENTICATION
 * @fqn wix.iam.verification.v1.VerificationService.ResendDuringAuthentication
 */
declare function resendDuringAuthentication(stateToken: string): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;

export { type Address, AddressTag, type AddressTagWithLiterals, type AddressWrapper, type AuthenticationExtensionInputs, type AuthenticationExtensionInputsLargeBlobOperationOneOf, type AuthenticatorConnection, type Connection, type ConnectionTypeOneOf, type CustomField, type CustomValue, type CustomValueValueOneOf, type Email, EmailTag, type EmailTagWithLiterals, type Factor, FactorStatus, type FactorStatusWithLiterals, FactorType, type FactorTypeWithLiterals, type Identity, type IdentityProfile, type IdpConnection, type ListValue, type MapValue, type Metadata, type MfaChallengeData, MfaReason, type MfaReasonWithLiterals, type Phone, PhoneTag, type PhoneTagWithLiterals, PrivacyStatus, type PrivacyStatusWithLiterals, type PublicKeyCredentialDescriptor, type PushChallengeData, Reason, type ReasonWithLiterals, type RequireMfaData, type ResendDuringAuthenticationRequest, type SecondaryEmail, type StartOptions, type StartRequest, type StartResponse, type StateMachineResponse, type StateMachineResponseStateDataOneOf, StateType, type StateTypeWithLiterals, Status, StatusName, type StatusNameWithLiterals, type StatusV2, type StatusWithLiterals, Target, type TargetWithLiterals, UserVerificationRequirement, type UserVerificationRequirementWithLiterals, type V1CustomValue, type V1CustomValueValueOneOf, type V1Factor, type V1ListValue, type V1MapValue, type VerificationChallenge, type VerificationChallengeFactorChallengeDataOneOf, type VerifyDuringAuthenticationOptions, type VerifyDuringAuthenticationRequest, type VerifyRequest, type VerifyResponse, type WebAuthnChallengeData, resendDuringAuthentication, start, verifyDuringAuthentication };
