import { HttpClient, NonNullablePaths, MaybeContext, BuildRESTFunction } from '@wix/sdk-types';
import { StartOptions, StartResponse, VerifyDuringAuthenticationOptions, StateMachineResponse } from './index.typings.js';
export { Address, AddressTag, AddressWrapper, AuthenticationExtensionInputs, AuthenticationExtensionInputsLargeBlobOperationOneOf, AuthenticatorConnection, Connection, ConnectionTypeOneOf, CustomField, CustomValue, CustomValueValueOneOf, Email, EmailTag, Factor, FactorStatus, FactorType, Identity, IdentityProfile, IdpConnection, ListValue, MapValue, Metadata, MfaChallengeData, MfaReason, Phone, PhoneTag, PrivacyStatus, PublicKeyCredentialDescriptor, PushChallengeData, Reason, RequireMfaData, ResendDuringAuthenticationRequest, SecondaryEmail, StartRequest, StateMachineResponseStateDataOneOf, StateType, Status, StatusName, StatusV2, Target, UserVerificationRequirement, V1CustomValue, V1CustomValueValueOneOf, V1Factor, V1ListValue, V1MapValue, VerificationChallenge, VerificationChallengeFactorChallengeDataOneOf, VerifyDuringAuthenticationRequest, VerifyRequest, VerifyResponse, WebAuthnChallengeData } from './index.typings.js';

type StartResponseNonNullablePaths = `verificationId`;
declare function start$1(httpClient: HttpClient): StartSignature;
interface StartSignature {
    /**
     * starts a verification process
     * example: sends a code to the identity's email
     */
    (options?: StartOptions): Promise<NonNullablePaths<StartResponse, StartResponseNonNullablePaths>>;
}
declare function verifyDuringAuthentication$1(httpClient: HttpClient): VerifyDuringAuthenticationSignature;
interface VerifyDuringAuthenticationSignature {
    /**
     * Continues the registration process when a member is required to verify an email address
     * using a verification code received by email.
     *
     * Email verification is required when the registering member is already listed as a contact.
     *
     * Typically, after a successful verification, you generate and use member tokens for the
     * registered member so that subsequent API calls are called as part of a member session.
     * @param - The code to verify.
     */
    (code: string, options: NonNullablePaths<VerifyDuringAuthenticationOptions, `stateToken`>): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
}
declare function resendDuringAuthentication$1(httpClient: HttpClient): ResendDuringAuthenticationSignature;
interface ResendDuringAuthenticationSignature {
    /**
     * Resend the verification email and continue the registration process when a member is required to verify an email address
     * using a verification code received by email.
     * @param - A state token representing the `REQUIRE_EMAIL_VERIFICATION` state.
     */
    (stateToken: string): Promise<NonNullablePaths<StateMachineResponse, `state` | `identity.connections` | `identity.connections.${number}.idpConnection.idpConnectionId` | `identity.connections.${number}.idpConnection.idpUserId` | `identity.connections.${number}.authenticatorConnection.authenticatorConnectionId` | `identity.connections.${number}.authenticatorConnection.reEnrollmentRequired` | `identity.identityProfile.emails` | `identity.identityProfile.phones` | `identity.identityProfile.labels` | `identity.identityProfile.privacyStatus` | `identity.identityProfile.customFields` | `identity.identityProfile.customFields.${number}.name` | `identity.identityProfile.customFields.${number}.value.strValue` | `identity.identityProfile.customFields.${number}.value.numValue` | `identity.identityProfile.secondaryEmails` | `identity.identityProfile.secondaryEmails.${number}.email` | `identity.identityProfile.secondaryEmails.${number}.tag` | `identity.identityProfile.phonesV2` | `identity.identityProfile.phonesV2.${number}.phone` | `identity.identityProfile.phonesV2.${number}.tag` | `identity.identityProfile.addresses` | `identity.identityProfile.addresses.${number}.tag` | `identity.email.address` | `identity.email.isVerified` | `identity.status.name` | `identity.status.reasons` | `identity.factors` | `identity.factors.${number}.factorId` | `identity.factors.${number}.type` | `identity.factors.${number}.status`>>;
}

declare const start: MaybeContext<BuildRESTFunction<typeof start$1> & typeof start$1>;
declare const verifyDuringAuthentication: MaybeContext<BuildRESTFunction<typeof verifyDuringAuthentication$1> & typeof verifyDuringAuthentication$1>;
declare const resendDuringAuthentication: MaybeContext<BuildRESTFunction<typeof resendDuringAuthentication$1> & typeof resendDuringAuthentication$1>;

export { StartOptions, StartResponse, StateMachineResponse, VerifyDuringAuthenticationOptions, resendDuringAuthentication, start, verifyDuringAuthentication };
