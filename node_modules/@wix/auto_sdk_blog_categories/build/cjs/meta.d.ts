import { CreateCategoryRequest as CreateCategoryRequest$1, CreateCategoryResponse as CreateCategoryResponse$1, UpdateCategoryRequest as UpdateCategoryRequest$1, UpdateCategoryResponse as UpdateCategoryResponse$1, GetCategoryRequest as GetCategoryRequest$1, GetCategoryResponse as GetCategoryResponse$1, GetCategoryBySlugRequest as GetCategoryBySlugRequest$1, GetCategoryBySlugResponse as GetCategoryBySlugResponse$1, ListCategoriesRequest as ListCategoriesRequest$1, ListCategoriesResponse as ListCategoriesResponse$1, QueryCategoriesRequest as QueryCategoriesRequest$1, QueryCategoriesResponse as QueryCategoriesResponse$1, DeleteCategoryRequest as DeleteCategoryRequest$1, DeleteCategoryResponse as DeleteCategoryResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

interface Category {
    /**
     * Category ID.
     * @immutable
     * @maxLength 38
     */
    id?: string;
    /**
     * Category label. Displayed in the Category Menu.
     * @maxLength 35
     */
    label?: string;
    /**
     * Number of posts in the category.
     * @readonly
     */
    postCount?: number;
    /**
     * The `url` of the page that lists every post with the specified category.
     * @readonly
     */
    url?: PageUrl;
    /**
     * Category description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Category title.
     * @maxLength 200
     * @deprecated Category title.
     * @targetRemovalDate 2025-07-16
     */
    title?: string;
    /**
     * Position of the category in the [Category Menu](https://support.wix.com/en/article/wix-blog-adding-and-customizing-a-category-menu).
     * Categories are displayed in ascending order. Categories with a position of `-1` appear at the end of the sequence.
     *
     * Default: `-1`
     */
    displayPosition?: number | null;
    /**
     * ID of the category's translations. All translations of a single category share the same `translationId`.
     * @format GUID
     */
    translationId?: string | null;
    /**
     * Category language.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * @immutable
     */
    language?: string | null;
    /**
     * Part of a category's URL that refers to a specific category. For example, the slug of `https:/example.com/blog/category/famous-cats` is `famous-cats`.
     * @maxLength 100
     */
    slug?: string;
    /** SEO data. */
    seoData?: SeoSchema;
    /** Category cover image. */
    coverImage?: Image;
    /**
     * Date and time the Category was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
}
interface PageUrl {
    /** The base URL. For premium sites, this is the domain. For free sites, this is the site URL. For example, `mysite.wixsite.com/mysite`. */
    base?: string;
    /** The relative path for the page within the site. For example, `/product-page/a-product`. */
    path?: string;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /**
     * The source that added the keyword terms to the SEO settings.
     * @maxLength 1000
     */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /**
     * User-selected keyword terms for a specific page.
     * @maxSize 5
     */
    keywords?: Keyword[];
}
interface Image {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
interface CreateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
declare enum Field {
    UNKNOWN = "UNKNOWN",
    /** Includes category URL. */
    URL = "URL",
    /** Includes SEO data. */
    SEO = "SEO"
}
/** @enumType */
type FieldWithLiterals = Field | 'UNKNOWN' | 'URL' | 'SEO';
interface CreateCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface UpdateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface UpdateCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface GetCategoryRequest {
    /**
     * Category ID.
     * @minLength 1
     * @maxLength 38
     */
    categoryId: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface GetCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface GetCategoryBySlugRequest {
    /**
     * Slug of the category to retrieve.
     * @minLength 1
     * @maxLength 100
     */
    slug: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Language of the category to retrieve.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
interface GetCategoryBySlugResponse {
    /** Category info. */
    category?: Category;
}
interface ListCategoriesRequest {
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive categories that are in that language.
     * If omitted, categories in all languages are returned.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
interface BlogPaging {
    /**
     * Number of items to skip in the current sort order.
     *
     *
     * Default: `0`
     */
    offset?: number;
    /**
     * Number of items to return.
     *
     *
     * Default:`50`
     * @min 1
     * @max 100
     */
    limit?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface ListCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    metaData?: MetaData;
}
interface MetaData {
    /** Number of items returned in this response. */
    count?: number;
    /** Requested offset. */
    offset?: number;
    /** Total number of items that match the query. */
    total?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface QueryCategoriesRequest {
    /** Query options. */
    query?: PlatformQuery;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 3
     */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface QueryCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor pointing to next page in the list of results.
     * @maxLength 2000
     */
    next?: string | null;
    /**
     * Cursor pointing to previous page in the list of results.
     * @maxLength 2000
     */
    prev?: string | null;
}
interface DeleteCategoryRequest {
    /**
     * Category ID.
     * @minLength 1
     * @maxLength 38
     */
    categoryId: string;
}
interface DeleteCategoryResponse {
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createCategory(): __PublicMethodMetaInfo<'POST', {}, CreateCategoryRequest$1, CreateCategoryRequest, CreateCategoryResponse$1, CreateCategoryResponse>;
declare function updateCategory(): __PublicMethodMetaInfo<'PATCH', {
    categoryId: string;
}, UpdateCategoryRequest$1, UpdateCategoryRequest, UpdateCategoryResponse$1, UpdateCategoryResponse>;
declare function getCategory(): __PublicMethodMetaInfo<'GET', {
    categoryId: string;
}, GetCategoryRequest$1, GetCategoryRequest, GetCategoryResponse$1, GetCategoryResponse>;
declare function getCategoryBySlug(): __PublicMethodMetaInfo<'GET', {
    slug: string;
}, GetCategoryBySlugRequest$1, GetCategoryBySlugRequest, GetCategoryBySlugResponse$1, GetCategoryBySlugResponse>;
declare function listCategories(): __PublicMethodMetaInfo<'GET', {}, ListCategoriesRequest$1, ListCategoriesRequest, ListCategoriesResponse$1, ListCategoriesResponse>;
declare function queryCategories(): __PublicMethodMetaInfo<'POST', {}, QueryCategoriesRequest$1, QueryCategoriesRequest, QueryCategoriesResponse$1, QueryCategoriesResponse>;
declare function deleteCategory(): __PublicMethodMetaInfo<'DELETE', {
    categoryId: string;
}, DeleteCategoryRequest$1, DeleteCategoryRequest, DeleteCategoryResponse$1, DeleteCategoryResponse>;

export { type __PublicMethodMetaInfo, createCategory, deleteCategory, getCategory, getCategoryBySlug, listCategories, queryCategories, updateCategory };
