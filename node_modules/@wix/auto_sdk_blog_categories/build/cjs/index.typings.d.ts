import { NonNullablePaths } from '@wix/sdk-types';

interface Category {
    /**
     * Category ID.
     * @immutable
     * @maxLength 38
     */
    _id?: string;
    /**
     * Category label. Displayed in the Category Menu.
     * @maxLength 35
     */
    label?: string;
    /**
     * Number of posts in the category.
     * @readonly
     */
    postCount?: number;
    /**
     * The `url` of the page that lists every post with the specified category.
     * @readonly
     */
    url?: string;
    /**
     * Category description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Category title.
     * @maxLength 200
     * @deprecated Category title.
     * @targetRemovalDate 2025-07-16
     */
    title?: string;
    /**
     * Position of the category in the [Category Menu](https://support.wix.com/en/article/wix-blog-adding-and-customizing-a-category-menu).
     * Categories are displayed in ascending order. Categories with a position of `-1` appear at the end of the sequence.
     *
     * Default: `-1`
     */
    displayPosition?: number | null;
    /**
     * ID of the category's translations. All translations of a single category share the same `translationId`.
     * @format GUID
     */
    translationId?: string | null;
    /**
     * Category language.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * @immutable
     */
    language?: string | null;
    /**
     * Part of a category's URL that refers to a specific category. For example, the slug of `https:/example.com/blog/category/famous-cats` is `famous-cats`.
     * @maxLength 100
     */
    slug?: string;
    /** SEO data. */
    seoData?: SeoSchema;
    /** Category cover image. */
    coverImage?: string;
    /**
     * Date and time the Category was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /**
     * The source that added the keyword terms to the SEO settings.
     * @maxLength 1000
     */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /**
     * User-selected keyword terms for a specific page.
     * @maxSize 5
     */
    keywords?: Keyword[];
}
interface FocalPoint {
    /** X-coordinate of the focal point. */
    x?: number;
    /** Y-coordinate of the focal point. */
    y?: number;
    /** crop by height */
    height?: number | null;
    /** crop by width */
    width?: number | null;
}
interface CategoryTranslation {
    /**
     * Category ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Label displayed in the categories menu on the site.
     * @maxLength 100
     */
    label?: string | null;
    /**
     * Language of the category.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
    /** URL of this category page. */
    url?: string;
}
interface InitialCategoriesCopied {
    /** Number of categories copied. */
    count?: number;
}
interface CreateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
declare enum Field {
    UNKNOWN = "UNKNOWN",
    /** Includes category URL. */
    URL = "URL",
    /** Includes SEO data. */
    SEO = "SEO"
}
/** @enumType */
type FieldWithLiterals = Field | 'UNKNOWN' | 'URL' | 'SEO';
interface CreateCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface BulkCreateCategoriesRequest {
    /**
     * Categories to create.
     * @minSize 1
     * @maxSize 50
     */
    categories?: Category[];
    /** Whether to return the full created category entities in the response. */
    returnFullEntity?: boolean;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface BulkCreateCategoriesResponse {
    /** Categories created by bulk action. */
    results?: BulkCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkCategoryResult {
    /** Bulk actions metadata for category. */
    itemMetadata?: ItemMetadata;
    /** Optional created category. */
    item?: Category;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateCategoriesRequest {
    /**
     * Categories to update.
     * @minSize 1
     * @maxSize 100
     */
    categories?: MaskedCategory[];
    /** Whether to return the full created category entities in the response. */
    returnFullEntity?: boolean;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface MaskedCategory {
    /** Category */
    category?: Category;
    /** Field mask of fields to update. */
    fieldMask?: string[];
}
interface BulkUpdateCategoriesResponse {
    /** Categories updated by bulk action. */
    results?: BulkCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface UpdateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface UpdateCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface GetCategoriesCountByLanguageRequest {
}
interface GetCategoriesCountByLanguageResponse {
    /** The language and it's count. */
    categoriesLanguageCount?: CategoryLanguageCount[];
}
interface CategoryLanguageCount {
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * @format LANGUAGE_TAG
     */
    languageCode?: string | null;
    /** The count of Categories for the language. */
    categoryCount?: number | null;
}
interface GetCategoryRequest {
    /**
     * Category ID.
     * @minLength 1
     * @maxLength 38
     */
    categoryId: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface GetCategoryResponse {
    /** Category info. */
    category?: Category;
}
interface GetCategoryBySlugRequest {
    /**
     * Slug of the category to retrieve.
     * @minLength 1
     * @maxLength 100
     */
    slug: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Language of the category to retrieve.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
interface GetCategoryBySlugResponse {
    /** Category info. */
    category?: Category;
}
interface ListCategoriesRequest {
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive categories that are in that language.
     * If omitted, categories in all languages are returned.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
interface BlogPaging {
    /**
     * Number of items to skip in the current sort order.
     *
     *
     * Default: `0`
     */
    offset?: number;
    /**
     * Number of items to return.
     *
     * Default: `50`
     *
     * Max: `100`
     * @min 1
     * @max 100
     */
    limit?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface ListCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    metaData?: MetaData;
}
interface MetaData {
    /** Number of items returned in this response. */
    count?: number;
    /** Requested offset. */
    offset?: number;
    /** Total number of items that match the query. */
    total?: number;
    /**
     * Pointer to the next or previous page in the list of results.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface QueryCategoriesRequest {
    /** Query options. */
    query?: PlatformQuery;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 3
     */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrderWithLiterals;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type SortOrderWithLiterals = SortOrder | 'ASC' | 'DESC';
interface Paging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 2000
     */
    cursor?: string | null;
}
interface QueryCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor pointing to next page in the list of results.
     * @maxLength 2000
     */
    next?: string | null;
    /**
     * Cursor pointing to previous page in the list of results.
     * @maxLength 2000
     */
    prev?: string | null;
}
interface BulkDeleteCategoryRequest {
    /**
     * Category IDs.
     * @minSize 1
     * @maxSize 100
     * @maxLength 38
     */
    categoryIds?: string[];
    /** Should delete bypassing the trash-bin. */
    permanent?: boolean;
}
interface BulkDeleteCategoryResponse {
}
interface DeleteCategoryRequest {
    /**
     * Category ID.
     * @minLength 1
     * @maxLength 38
     */
    categoryId: string;
}
interface DeleteCategoryResponse {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityTypeWithLiterals;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
/** @enumType */
type WebhookIdentityTypeWithLiterals = WebhookIdentityType | 'UNKNOWN' | 'ANONYMOUS_VISITOR' | 'MEMBER' | 'WIX_USER' | 'APP';
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
interface CategoryCreatedEnvelope {
    entity: Category;
    metadata: EventMetadata;
}
/**
 * Triggered when a category is created.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_created
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug created
 */
declare function onCategoryCreated(handler: (event: CategoryCreatedEnvelope) => void | Promise<void>): void;
interface CategoryDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggered when a category is deleted.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_deleted
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug deleted
 */
declare function onCategoryDeleted(handler: (event: CategoryDeletedEnvelope) => void | Promise<void>): void;
interface CategoryUpdatedEnvelope {
    entity: Category;
    metadata: EventMetadata;
}
/**
 * Triggered when a category is updated.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_updated
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug updated
 */
declare function onCategoryUpdated(handler: (event: CategoryUpdatedEnvelope) => void | Promise<void>): void;
type CategoryNonNullablePaths = `_id` | `label` | `postCount` | `title` | `slug` | `seoData.tags` | `seoData.tags.${number}.type` | `seoData.tags.${number}.children` | `seoData.tags.${number}.custom` | `seoData.tags.${number}.disabled` | `seoData.settings.preventAutoRedirect` | `seoData.settings.keywords` | `seoData.settings.keywords.${number}.term` | `seoData.settings.keywords.${number}.isMain`;
/**
 * Creates a category.
 * @param category - Category info.
 * @public
 * @requiredField category
 * @requiredField category.label
 * @permissionId BLOG.CREATE-CATEGORY
 * @applicableIdentity APP
 * @returns Category info.
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.CreateCategory
 */
declare function createCategory(category: NonNullablePaths<Category, `label`>, options?: CreateCategoryOptions): Promise<NonNullablePaths<Category, CategoryNonNullablePaths>>;
interface CreateCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
/**
 * Updates a category.
 * @param _id - Category ID.
 * @public
 * @requiredField _id
 * @requiredField category
 * @permissionId BLOG.EDIT-CATEGORY
 * @applicableIdentity APP
 * @returns Category info.
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.UpdateCategory
 */
declare function updateCategory(_id: string, category: UpdateCategory, options?: UpdateCategoryOptions): Promise<NonNullablePaths<Category, CategoryNonNullablePaths>>;
interface UpdateCategory {
    /**
     * Category ID.
     * @immutable
     * @maxLength 38
     */
    _id?: string;
    /**
     * Category label. Displayed in the Category Menu.
     * @maxLength 35
     */
    label?: string;
    /**
     * Number of posts in the category.
     * @readonly
     */
    postCount?: number;
    /**
     * The `url` of the page that lists every post with the specified category.
     * @readonly
     */
    url?: string;
    /**
     * Category description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Category title.
     * @maxLength 200
     * @deprecated Category title.
     * @targetRemovalDate 2025-07-16
     */
    title?: string;
    /**
     * Position of the category in the [Category Menu](https://support.wix.com/en/article/wix-blog-adding-and-customizing-a-category-menu).
     * Categories are displayed in ascending order. Categories with a position of `-1` appear at the end of the sequence.
     *
     * Default: `-1`
     */
    displayPosition?: number | null;
    /**
     * ID of the category's translations. All translations of a single category share the same `translationId`.
     * @format GUID
     */
    translationId?: string | null;
    /**
     * Category language.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * @immutable
     */
    language?: string | null;
    /**
     * Part of a category's URL that refers to a specific category. For example, the slug of `https:/example.com/blog/category/famous-cats` is `famous-cats`.
     * @maxLength 100
     */
    slug?: string;
    /** SEO data. */
    seoData?: SeoSchema;
    /** Category cover image. */
    coverImage?: string;
    /**
     * Date and time the Category was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
interface UpdateCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
/**
 * Gets a category with the specified ID.
 * @param categoryId - Category ID.
 * @public
 * @requiredField categoryId
 * @param options - Options specifying which fields to return.
 * @permissionId BLOG.READ-CATEGORY
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.GetCategory
 */
declare function getCategory(categoryId: string, options?: GetCategoryOptions): Promise<NonNullablePaths<GetCategoryResponse, {
    [P in CategoryNonNullablePaths]: `category.${P}`;
}[CategoryNonNullablePaths]>>;
interface GetCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
}
/**
 * Gets a category with the specified slug.
 *
 * The slug is at the end of the URL of a specific category.
 * For example, if a category's URL is `https://example.com/blog/categories/famous-cats`, the slug is `famous-cats`.
 * The slug is a case-sensitive string that is derived from the category's label, unless specified otherwise.
 * @public
 * @requiredField slug
 * @param slug - Slug of the category to retrieve.
 *
 * The end of a category's URL. For example, `'https:/example.com/blog/category/{my-category-slug}'`. Case sensitive and generally based on the category `label` if not specified.
 * @param options - Options specifying which fields to return.
 * @permissionId BLOG.READ-CATEGORY
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.GetCategoryBySlug
 */
declare function getCategoryBySlug(slug: string, options?: GetCategoryBySlugOptions): Promise<NonNullablePaths<GetCategoryBySlugResponse, {
    [P in CategoryNonNullablePaths]: `category.${P}`;
}[CategoryNonNullablePaths]>>;
interface GetCategoryBySlugOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Language of the category to retrieve.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
/**
 * Retrieves a list of up to 100 categories per request.
 *
 * If you pass a language filter to the method, it returns a list of up to 100 categories in the requested language.
 *
 * The categoies are displayed in order of their `displayPosition`, starting with `0`. The `displayPosition` is the position in which the categories
 * are displayed in the Category Menu page. By default, categories get added to the bottom of the Category Menu page with a `displayPosition` of `-1`.
 *
 * List Categories runs with these defaults, which you can override:
 * - `paging.limit` is `50`.
 * - `paging.offset` is `0`.
 *
 * List Categories is sorted by `displayPosition` in descending order. This cannot be overridden.
 * @public
 * @param options - Filter and paging options.
 * @permissionId BLOG.READ-CATEGORY
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.ListCategories
 */
declare function listCategories(options?: ListCategoriesOptions): Promise<NonNullablePaths<ListCategoriesResponse, {
    [P in CategoryNonNullablePaths]: `categories.${number}.${P}`;
}[CategoryNonNullablePaths] | `metaData.count` | `metaData.offset` | `metaData.total`>>;
interface ListCategoriesOptions {
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     * @maxSize 10
     */
    fieldsets?: FieldWithLiterals[];
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive categories that are in that language.
     * If omitted, categories in all languages are returned.
     * @format LANGUAGE_TAG
     */
    language?: string | null;
}
/**
 * Creates a query to retrieve a list of categories.
 *
 *
 * The Query Categories method builds a query to retrieve a list of up to 100 categories per language, and returns a [`CategoriesQueryBuilder`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/ascending) object.
 *
 * The response contains the query definition, which is typically used to run the query using the [`find()`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/find) method.
 *
 * You can refine the query by chaining `CategoriesQueryBuilder` methods to the query. `CategoriesQueryBuilder` methods enable you to sort, filter, and control the results that Query Categories returns. Any methods chained to the Query Categories method are applied in the order that they are called.
 *
 * Query Categories runs with these `CategoriesQueryBuilder` defaults, which you can override.
 * - [`limit(100)`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/limit)
 * - [`ascending(displayPosition)`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/ascending)
 *
 * The following `CategoriesQueryBuilder` methods are supported for Query Categories. For a full description of the `Categories` object, see the response for the [`items`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-result/items) property in [`CategoriesQueryResult`](https://www.wix.com/velo/reference/wix-blog-backend/categories/categoriesqueryresult).
 * @public
 * @param options - Options specifying which fields to return.
 * @permissionId BLOG.READ-CATEGORY
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.QueryCategories
 */
declare function queryCategories(options?: QueryCategoriesOptions): CategoriesQueryBuilder;
interface QueryCategoriesOptions {
    /**
  
     * @maxSize 10
       */
    fieldsets?: FieldWithLiterals[] | undefined;
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface CategoriesQueryResult extends QueryOffsetResult {
    items: Category[];
    query: CategoriesQueryBuilder;
    next: () => Promise<CategoriesQueryResult>;
    prev: () => Promise<CategoriesQueryResult>;
}
interface CategoriesQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: 'label' | 'postCount' | 'title' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: 'label' | 'postCount' | 'title' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: 'label' | 'postCount' | 'title' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: 'label' | 'postCount' | 'title' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: 'label' | 'title', value: string) => CategoriesQueryBuilder;
    in: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug', value: any) => CategoriesQueryBuilder;
    exists: (propertyName: 'label' | 'title' | 'translationId' | 'language' | 'slug', value: boolean) => CategoriesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'language' | 'slug'>) => CategoriesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'language' | 'slug'>) => CategoriesQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => CategoriesQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results. */
    skip: (skip: number) => CategoriesQueryBuilder;
    find: () => Promise<CategoriesQueryResult>;
}
/**
 * Deletes a category.
 * @param categoryId - Category ID.
 * @public
 * @requiredField categoryId
 * @permissionId BLOG.DELETE-CATEGORY
 * @applicableIdentity APP
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.DeleteCategory
 */
declare function deleteCategory(categoryId: string): Promise<void>;

export { type ActionEvent, type ApplicationError, type BaseEventMetadata, type BlogPaging, type BulkActionMetadata, type BulkCategoryResult, type BulkCreateCategoriesRequest, type BulkCreateCategoriesResponse, type BulkDeleteCategoryRequest, type BulkDeleteCategoryResponse, type BulkUpdateCategoriesRequest, type BulkUpdateCategoriesResponse, type CategoriesQueryBuilder, type CategoriesQueryResult, type Category, type CategoryCreatedEnvelope, type CategoryDeletedEnvelope, type CategoryLanguageCount, type CategoryTranslation, type CategoryUpdatedEnvelope, type CreateCategoryOptions, type CreateCategoryRequest, type CreateCategoryResponse, type CursorPaging, type Cursors, type DeleteCategoryRequest, type DeleteCategoryResponse, type DomainEvent, type DomainEventBodyOneOf, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, Field, type FieldWithLiterals, type FocalPoint, type GetCategoriesCountByLanguageRequest, type GetCategoriesCountByLanguageResponse, type GetCategoryBySlugOptions, type GetCategoryBySlugRequest, type GetCategoryBySlugResponse, type GetCategoryOptions, type GetCategoryRequest, type GetCategoryResponse, type IdentificationData, type IdentificationDataIdOneOf, type InitialCategoriesCopied, type ItemMetadata, type Keyword, type ListCategoriesOptions, type ListCategoriesRequest, type ListCategoriesResponse, type MaskedCategory, type MessageEnvelope, type MetaData, type Paging, type PagingMetadataV2, type PlatformQuery, type PlatformQueryPagingMethodOneOf, type QueryCategoriesOptions, type QueryCategoriesRequest, type QueryCategoriesResponse, type RestoreInfo, type SeoSchema, type Settings, SortOrder, type SortOrderWithLiterals, type Sorting, type Tag, type UpdateCategory, type UpdateCategoryOptions, type UpdateCategoryRequest, type UpdateCategoryResponse, WebhookIdentityType, type WebhookIdentityTypeWithLiterals, createCategory, deleteCategory, getCategory, getCategoryBySlug, listCategories, onCategoryCreated, onCategoryDeleted, onCategoryUpdated, queryCategories, updateCategory };
